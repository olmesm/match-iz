/*
 * match-iz
 * v3.0.0
 * https://github.com/shuckster/match-iz
 * License: MIT
 */
var N=Object.defineProperty;var C=Object.getOwnPropertyDescriptor;var G=Object.getOwnPropertyNames,P=Object.getOwnPropertySymbols;var W=Object.prototype.hasOwnProperty,H=Object.prototype.propertyIsEnumerable;var l=(t,n)=>{var o={};for(var s in t)W.call(t,s)&&n.indexOf(s)<0&&(o[s]=t[s]);if(t!=null&&P)for(var s of P(t))n.indexOf(s)<0&&H.call(t,s)&&(o[s]=t[s]);return o};var d=(t,n)=>{for(var o in n)N(t,o,{get:n[o],enumerable:!0})},J=(t,n,o,s)=>{if(n&&typeof n=="object"||typeof n=="function")for(let r of G(n))!W.call(t,r)&&r!==o&&N(t,r,{get:()=>n[r],enumerable:!(s=C(n,r))||s.enumerable});return t};var K=t=>J(N({},"__esModule",{value:!0}),t);var jt={};d(jt,{against:()=>I,allOf:()=>tt,anyOf:()=>q,cata:()=>pt,defined:()=>nt,empty:()=>z,endsWith:()=>ft,falsy:()=>bt,gt:()=>ot,gte:()=>rt,hasOwn:()=>mt,inRange:()=>ct,includedIn:()=>ut,includes:()=>gt,instanceOf:()=>_,isArray:()=>i,isDate:()=>Z,isFunction:()=>c,isNumber:()=>R,isPojo:()=>b,isRegExp:()=>w,isString:()=>f,lt:()=>st,lte:()=>et,match:()=>$,not:()=>a,otherwise:()=>y,pluck:()=>k,spread:()=>xt,startsWith:()=>it,truthy:()=>Ot,when:()=>v});module.exports=K(jt);var O={};d(O,{instanceOf:()=>j,isArguments:()=>D,isArray:()=>M,isDate:()=>Q,isFunction:()=>T,isNumber:()=>V,isObject:()=>F,isPojo:()=>Y,isRegExp:()=>X,isString:()=>U});var A=Object.prototype,L=A.toString,p=t=>n=>typeof n===t,j=t=>n=>n instanceof t,{isArray:M}=Array,D=t=>L.call(t)==="[object Arguments]",Q=t=>j(Date)(t)&&!isNaN(t),T=p("function"),U=p("string"),V=t=>t===t&&p("number")(t),F=t=>t!==null&&p("object")(t),X=j(RegExp),Y=t=>t===null||!F(t)||D(t)?!1:Object.getPrototypeOf(t)===A;var{isArray:i,isDate:Z,isFunction:c,isNumber:R}=O,{isPojo:b,isRegExp:w,isString:f,instanceOf:_}=O;function $(t){return(...n)=>I(...n)(t)}var I=(...t)=>{let n;return o=>t.find(s=>{let r=s(o),{matched:u,value:m}=r||{};return[u,m].every(c)?u(o)&&(n=m(o),!0):r&&(n=r)})&&n},y=t=>n=>({matched:()=>!0,value:()=>c(t)?t(n):t}),E=t=>n=>o=>({matched:()=>e(t,o,s=>o=s),value:()=>c(n)?f(o)&&w(t)?n(...h(o.match(t))):n(o):n}),v=(...t)=>{if(t.length===1){let[n]=t;return E(n)}if(t.length===2){let[n,o]=t;return E(n)(o)}throw new Error("expected 1 or 2 arguments")},h=t=>{let{groups:n}=t;return n?[n,t]:[t]},e=(t,n,o)=>b(t)?Object.keys(t).every(s=>e(t[s],n==null?void 0:n[s],o)):i(t)?i(n)&&t.length===n.length&&t.every((s,r)=>e(s,n==null?void 0:n[r],o)):c(t)?t(n,o):f(n)&&w(t)?t.test(n):t===n||[t,n].every(Number.isNaN),k=(...t)=>(n,o)=>t.length===0||(c(t[0])?t[0](n):e(t[0],n,o))?(o(n),!0):!1,a=t=>(n,o)=>!e(t,n,o),q=(...t)=>(n,o)=>t.flat().some(s=>e(s,n,o)),tt=(...t)=>(n,o)=>t.flat().every(s=>e(s,n,o)),z=t=>t!==t||!t&&t!==0&&t!==!1||i(t)&&!t.length||b(t)&&!Object.keys(t).length,nt=t=>!z(t),ot=t=>g(n=>n>t),st=t=>g(n=>n<t),rt=t=>g(n=>n>=t),et=t=>g(n=>n<=t),ct=(t,n)=>g(o=>o>=Math.min(t,n)&&o<=Math.max(t,n)),it=t=>B(n=>n.startsWith(t)),ft=t=>B(n=>n.endsWith(t)),gt=t=>Nt(n=>n.includes(t)),ut=q,mt=(...t)=>n=>b(n)&&(([o,s])=>o.length&&o.every(r=>s.includes(r)))([t.flat(),Object.keys(n)]),pt=o=>{var s=o,{getValue:t}=s,n=l(s,["getValue"]);return Object.entries(n).reduce((r,[u,m])=>Object.assign(r,{[u]:x=>S=>({matched:()=>m(S),value:()=>c(x)?x(t(S)):x})}),{})},Ot=t=>!!t,bt=t=>!t,xt=t=>new Proxy({},{get:()=>t}),B=t=>n=>f(n)&&t(n),g=t=>n=>R(n)&&t(n),Nt=t=>n=>(i(n)||f(n))&&t(n);0&&(module.exports={against,allOf,anyOf,cata,defined,empty,endsWith,falsy,gt,gte,hasOwn,inRange,includedIn,includes,instanceOf,isArray,isDate,isFunction,isNumber,isPojo,isRegExp,isString,lt,lte,match,not,otherwise,pluck,spread,startsWith,truthy,when});
