/*
 * match-iz
 * v3.8.1
 * https://github.com/shuckster/match-iz
 * License: MIT
 */
var D=Object.defineProperty;var p=Object.getOwnPropertySymbols;var E=Object.prototype.hasOwnProperty,F=Object.prototype.propertyIsEnumerable;var q=(t,n,o)=>n in t?D(t,n,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[n]=o,d=(t,n)=>{for(var o in n||(n={}))E.call(n,o)&&q(t,o,n[o]);if(p)for(var o of p(n))F.call(n,o)&&q(t,o,n[o]);return t};var R=(t,n)=>{var o={};for(var s in t)E.call(t,s)&&n.indexOf(s)<0&&(o[s]=t[s]);if(t!=null&&p)for(var s of p(t))n.indexOf(s)<0&&F.call(t,s)&&(o[s]=t[s]);return o};var G=(t,n)=>{for(var o in n)D(t,o,{get:n[o],enumerable:!0})};var x={};G(x,{instanceOf:()=>S,isArguments:()=>I,isArray:()=>J,isDate:()=>K,isFunction:()=>L,isNumber:()=>Q,isObject:()=>V,isPojo:()=>U,isRegExp:()=>T,isString:()=>M});var v=Object.prototype,H=v.toString,O=t=>n=>typeof n===t,S=t=>n=>n instanceof t,{isArray:J}=Array,I=t=>H.call(t)==="[object Arguments]",K=t=>S(Date)(t)&&!isNaN(t),L=O("function"),M=O("string"),Q=t=>t===t&&O("number")(t),V=t=>t!==null&&O("object")(t),T=S(RegExp),U=t=>t===null||!V(t)||I(t)?!1:Object.getPrototypeOf(t)===v;var{isArray:i,isDate:st,isFunction:g,isNumber:X}=x,{isPojo:u,isRegExp:z,isString:N,instanceOf:et}=x,{keys:c,entries:Y,assign:Z}=Object;function rt(t){return(...n)=>_(...n)(t)}var _=(...t)=>{let n;return o=>t.find(s=>{let r=s(o),{matched:m,value:l}=r||{};return[m,l].every(g)?m(o)&&(n=l(o),!0):r&&(n=r)})&&n},it=t=>n=>({matched:()=>!0,value:()=>g(t)?t(n):t}),W=t=>n=>o=>({matched:()=>e(t,o,s=>o=s),value:()=>g(n)?N(o)&&z(t)?n(...$(o.match(t))):n(o):n}),ct=(...t)=>{if(t.length===1){let[n]=t;return W(n)}if(t.length===2){let[n,o]=t;return W(n)(o)}if(t.length>2){let n=t.slice(-1)[0],o=t.slice(0,-1);return W(k(o))(n)}throw new Error("expected 1 or 2 arguments")},$=t=>{let{groups:n}=t;return n?[n,t]:[t]},e=(t,n,o)=>u(t)?c(t).every(s=>e(t[s],n==null?void 0:n[s],o)):i(t)?i(n)&&t.length===n.length&&t.every((s,r)=>e(s,n==null?void 0:n[r],o)):g(t)?t(n,o):N(n)&&z(t)?t.test(n):t===n||[t,n].every(Number.isNaN),gt=(...t)=>(n,o)=>t.length===0||(g(t[0])?t[0](n):e(t[0],n,o))?(o(n),!0):!1,j=(t,n)=>[t,n].every(u)?c(t).length===c(n).length:!0,h=t=>(n,o)=>j(t,n)&&e(t,n,o),ut=t=>P(t,n=>u(n)?h(n):n),ft=t=>(n,o)=>!e(t,n,o),y=(...t)=>(n,o)=>t.flat().some(s=>e(s,n,o)),k=(...t)=>(n,o)=>t.flat().every(s=>e(s,n,o)),mt=t=>C(n=>n.every(o=>e(t,o))),lt=t=>C(n=>n.some(o=>e(t,o))),pt=(...t)=>b((n,o)=>t.length<=n.length&&e(t,n.slice(0,t.length),o)),Ot=(...t)=>b((n,o)=>t.length<=n.length&&e(t,n.slice(n.length-t.length),o)),a=t=>t!==t||!t&&t!==0&&t!==!1||i(t)&&!t.length||u(t)&&!c(t).length,xt=t=>!a(t),Nt=t=>f(n=>n>t),wt=t=>f(n=>n<t),St=t=>f(n=>n>=t),Wt=t=>f(n=>n<=t),Pt=(t,n)=>f(o=>o>=Math.min(t,n)&&o<=Math.max(t,n)),bt=t=>B(n=>n.startsWith(t)),At=t=>B(n=>n.endsWith(t)),qt=t=>b(n=>n.includes(t)),Dt=y,Et=t=>n=>n===t,Ft=(...t)=>n=>u(n)&&(([o,s])=>o.length&&o.every(r=>s.includes(r)))([t.flat(),c(n)]),dt=o=>{var s=o,{getValue:t}=s,n=R(s,["getValue"]);return Y(n).reduce((r,[m,l])=>Z(r,{[m]:w=>A=>({matched:()=>l(A),value:()=>g(w)?w(t(A)):w})}),{})},Rt=t=>!!t,vt=t=>!t,tt=t=>(n,o)=>(n[o]=P(n[o],t),n),nt=t=>n=>P(n,t),P=(t,n)=>n(u(t)?c(t).reduce(tt(n),d({},t)):i(t)?t.map(nt(n)):t),It=t=>new Proxy({},{get:()=>t}),B=t=>n=>N(n)&&t(n),f=t=>n=>X(n)&&t(n),C=t=>(n,o)=>i(n)&&t(n,o),b=t=>(n,o)=>(i(n)||N(n))&&t(n,o);export{_ as against,k as allOf,y as anyOf,dt as cata,ut as deepEq,xt as defined,a as empty,At as endsWith,h as eq,mt as every,vt as falsy,pt as firstOf,Nt as gt,St as gte,Ft as hasOwn,Pt as inRange,Dt as includedIn,qt as includes,et as instanceOf,i as isArray,st as isDate,g as isFunction,X as isNumber,u as isPojo,z as isRegExp,Et as isStrictly,N as isString,Ot as lastOf,wt as lt,Wt as lte,rt as match,ft as not,it as otherwise,gt as pluck,lt as some,It as spread,bt as startsWith,Rt as truthy,ct as when};
