/*
 * match-iz
 * v2.3.2
 * https://github.com/shuckster/match-iz
 * License: MIT
 */
var F=Object.defineProperty;var w=Object.getOwnPropertySymbols;var E=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable;var S=(t,n)=>{var o={};for(var s in t)E.call(t,s)&&n.indexOf(s)<0&&(o[s]=t[s]);if(t!=null&&w)for(var s of w(t))n.indexOf(s)<0&&R.call(t,s)&&(o[s]=t[s]);return o};var I=(t,n)=>{for(var o in n)F(t,o,{get:n[o],enumerable:!0})};var m={};I(m,{instanceOf:()=>x,isArguments:()=>W,isArray:()=>z,isDate:()=>B,isFunction:()=>C,isNumber:()=>H,isObject:()=>l,isPojo:()=>K,isRegExp:()=>J,isString:()=>G});var P=Object.prototype,q=P.toString,u=t=>n=>typeof n===t,x=t=>n=>n instanceof t,{isArray:z}=Array,W=t=>q.call(t)==="[object Arguments]",B=t=>x(Date)(t)&&!isNaN(t),C=u("function"),G=u("string"),H=t=>t===t&&u("number")(t),l=t=>t!==null&&u("object")(t),J=x(RegExp),K=t=>t===null||!l(t)||W(t)?!1:Object.getPrototypeOf(t)===P;var{isArray:p,isDate:Y,isFunction:c,isNumber:L}=m,{isPojo:N,isRegExp:A,isString:O,instanceOf:Z}=m;function _(t){return(...n)=>M(...n)(t)}var M=(...t)=>{let n;return o=>t.find(s=>{let r=s(o),{matched:f,value:g}=r||{};return[f,g].every(c)?f(o)&&(n=g(o),!0):r&&(n=r)})&&n},$=t=>n=>({matched:()=>!0,value:()=>c(t)?t(n):t}),d=t=>n=>o=>({matched:()=>e(t,o,s=>o=s),value:()=>c(n)?O(o)&&A(t)?n(...Q(o.match(t))):n(o):n}),y=(...t)=>{if(t.length===1){let[n]=t;return d(n)}if(t.length===2){let[n,o]=t;return d(n)(o)}throw new Error("expected 1 or 2 arguments")},Q=t=>{let{groups:n}=t;return n?[n,t]:[t]},e=(t,n,o)=>N(t)?Object.keys(t).every(s=>e(t[s],n==null?void 0:n[s],o)):p(t)?p(n)&&t.length===n.length&&t.every((s,r)=>e(s,n==null?void 0:n[r],o)):c(t)?t(n,o):O(n)&&A(t)?t.test(n):t===n||[t,n].every(Number.isNaN),v=(...t)=>(n,o)=>t.length===0||(c(t[0])?t[0](n):e(t[0],n,o))?(o(n),!0):!1,h=t=>(n,o)=>!e(t,n,o),T=(...t)=>(n,o)=>t.flat().some(s=>e(s,n,o)),k=(...t)=>(n,o)=>t.flat().every(s=>e(s,n,o)),U=t=>t!==t||!t&&t!==0&&t!==!1||p(t)&&!t.length||N(t)&&!Object.keys(t).length,a=t=>!U(t),tt=t=>i(n=>n>t),nt=t=>i(n=>n<t),ot=t=>i(n=>n>=t),st=t=>i(n=>n<=t),rt=(t,n)=>i(o=>o>=Math.min(t,n)&&o<=Math.max(t,n)),et=t=>D(n=>n.startsWith(t)),ct=t=>D(n=>n.endsWith(t)),it=t=>V(n=>n.includes(t)),ft=T,gt=(...t)=>n=>N(n)&&(([o,s])=>o.length&&o.every(r=>s.includes(r)))([t.flat(),Object.keys(n)]),ut=o=>{var s=o,{getValue:t}=s,n=S(s,["getValue"]);return Object.entries(n).reduce((r,[f,g])=>Object.assign(r,{[f]:b=>j=>({matched:()=>g(j),value:()=>c(b)?b(t(j)):b})}),{})},mt=t=>!!t,pt=t=>!t,Ot=t=>new Proxy({},{get:()=>t}),D=t=>n=>O(n)&&t(n),i=t=>n=>L(n)&&t(n),V=t=>n=>(p(n)||O(n))&&t(n);export{M as against,k as allOf,T as anyOf,ut as cata,a as defined,U as empty,ct as endsWith,pt as falsy,tt as gt,ot as gte,gt as hasOwn,rt as inRange,ft as includedIn,it as includes,Z as instanceOf,p as isArray,Y as isDate,c as isFunction,L as isNumber,N as isPojo,A as isRegExp,O as isString,nt as lt,st as lte,_ as match,h as not,$ as otherwise,v as pluck,Ot as spread,et as startsWith,mt as truthy,y as when};
