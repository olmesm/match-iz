/*
 * match-iz
 * v1.8.1
 * https://github.com/shuckster/match-iz
 * License: MIT
 */
var j=Object.prototype,N=j.toString,e=t=>n=>typeof n===t,S=t=>N.call(t)==="[object Arguments]",r=Array.isArray,i=e("function"),A=e("number"),c=e("string"),P=t=>t!==null&&e("object")(t),p=t=>t instanceof RegExp,u=t=>t===null||!P(t)||S(t)?!1:Object.getPrototypeOf(t)===j;function q(t){return(...n)=>R(...n)(t)}var R=(...t)=>{let n;return o=>t.find(f=>{let m=f(o),{matched:O,value:b}=m||{};return[O,b].every(i)?O(o)&&(n=b(o),!0):m&&(n=m)})&&n},y=t=>n=>({matched:()=>!0,value:()=>i(t)?t(n):t}),z=t=>n=>o=>({matched:()=>s(t,o),value:()=>i(n)?c(o)&&p(t)?n(o.match(t)):n(o):n}),s=(t,n)=>u(t)?Object.keys(t).every(o=>s(t[o],n==null?void 0:n[o])):r(t)?r(n)?t.length===n.length&&t.every((o,f)=>s(o,n==null?void 0:n[f])):t.some(o=>s(o,n)):i(t)?t(n):c(n)&&p(t)?t.test(n):t===n||[t,n].every(Number.isNaN),B=t=>n=>!s(t,n),W=(...t)=>t.flat(),C=(...t)=>n=>t.flat().every(o=>s(o,n)),w=t=>t!==t||!t&&t!==0&&t!==!1||r(t)&&!t.length||u(t)&&!Object.keys(t).length,D=t=>!w(t),G=t=>g(n=>n>t),H=t=>g(n=>n<t),J=t=>g(n=>n>=t),K=t=>g(n=>n<=t),L=(t,n)=>g(o=>o>=t&&o<=n),M=t=>x(n=>n.startsWith(t)),Q=t=>x(n=>n.endsWith(t)),T=t=>E(n=>n.includes(t)),U=W,V=t=>!!t,X=t=>!t,Y=t=>new Proxy({},{get:()=>t}),x=t=>n=>c(n)&&t(n),g=t=>n=>A(n)&&t(n),E=t=>n=>(r(n)||c(n))&&t(n);export{R as against,C as allOf,W as anyOf,D as defined,w as empty,Q as endsWith,X as falsy,G as gt,J as gte,L as inRange,U as includedIn,T as includes,r as isArray,i as isFunction,A as isNumber,u as isPojo,p as isRegExp,c as isString,H as lt,K as lte,q as match,B as not,y as otherwise,Y as spread,M as startsWith,V as truthy,z as when};
